#!/usr/bin/env node

/**
 * Automated Claude Code Session Documentation Watcher
 * 
 * Monitors .claude-trace/ directory for new session logs and automatically
 * extracts summaries, storing them for searchable session history.
 * 
 * Usage: node scripts/auto-session-watcher.js [--daemon]
 */

const fs = require('fs');
const path = require('path');
const { extractSessionTitle, extractSessionMetadata, generateSessionSummary } = require('./extract-session-summary.js');

class SessionWatcher {
    constructor(options = {}) {
        this.traceDir = options.traceDir || '/home/neil/dev/new-claude-travel-agent/.claude-trace';
        this.outputDir = options.outputDir || '/tmp/claude-sessions';
        this.processingFiles = new Set(); // Track files being processed
        this.fileStabilityDelay = options.fileStabilityDelay || 5000; // Wait 5s for file to stabilize
        this.isDaemon = options.daemon || false;
        
        // Ensure output directory exists
        this.ensureOutputDirectory();
        
        console.log(`🔍 Session Watcher initialized`);
        console.log(`   Watching: ${this.traceDir}`);
        console.log(`   Output: ${this.outputDir}`);
        console.log(`   Stability delay: ${this.fileStabilityDelay}ms`);
    }
    
    ensureOutputDirectory() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
            console.log(`📁 Created output directory: ${this.outputDir}`);
        }
    }
    
    /**
     * Check if a JSONL file appears to be complete/stable
     */
    async isFileStable(filePath) {
        try {
            const stats1 = fs.statSync(filePath);
            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
            const stats2 = fs.statSync(filePath);
            
            // File is stable if size hasn't changed
            return stats1.size === stats2.size && stats1.mtime.getTime() === stats2.mtime.getTime();
        } catch (error) {
            return false; // File might have been deleted or is inaccessible
        }
    }
    
    /**
     * Process a single session file
     */
    async processSessionFile(filename) {
        const filePath = path.join(this.traceDir, filename);
        
        try {
            console.log(`\n🔄 Processing: ${filename}`);
            
            // Extract session data
            const sessionData = extractSessionMetadata(filePath);
            const titleData = extractSessionTitle(filePath);
            
            if (!titleData.hasTitle) {
                console.log(`   ⚠️  No session title found - skipping`);
                return false;
            }
            
            // Generate summary
            const summary = generateSessionSummary(sessionData, titleData);
            
            // Save to output directory
            const outputPath = path.join(this.outputDir, `session-${summary.timestamp}.json`);
            fs.writeFileSync(outputPath, JSON.stringify(summary, null, 2));
            
            console.log(`   ✅ Extracted: "${summary.title}"`);
            console.log(`   💾 Saved: ${outputPath}`);
            console.log(`   📊 Size: ${Math.round(summary.fileSize / 1024)}KB`);
            
            // TODO: Store in simple-memory MCP when available
            await this.storeInMemory(summary);
            
            return true;
            
        } catch (error) {
            console.error(`   ❌ Error processing ${filename}:`, error.message);
            return false;
        }
    }
    
    /**
     * Store session summary directly in basic-memory
     */
    async storeInMemory(summary) {
        // Format for basic-memory storage
        const noteContent = `Session Summary
=================

**Timestamp:** ${summary.timestamp}
**Source:** ${summary.source}
**Tags:** ${summary.tags.join(', ')}
**File Size:** ${Math.round(summary.fileSize / 1024)}KB
**Last Modified:** ${summary.lastModified}

**Preview:**
${summary.preview}

**Metadata:**
${JSON.stringify({
    filename: summary.filename,
    timestamp: summary.timestamp,
    fileSize: summary.fileSize
}, null, 2)}

---
Generated by Claude Code Session Automation
`;

        try {
            // First, save MCP-ready format as backup
            const mcpReadyPath = path.join(this.outputDir, `mcp-ready-${summary.timestamp}.txt`);
            const mcpData = {
                action: 'create_note',
                title: summary.title,
                content: noteContent
            };
            fs.writeFileSync(mcpReadyPath, JSON.stringify(mcpData, null, 2));
            
            // Now directly import into basic-memory
            await this.importToBasicMemory(summary.title, noteContent);
            console.log(`   🧠 Auto-imported to basic-memory: "${summary.title}"`);
            
            // Mark as imported by renaming the backup file
            const importedPath = mcpReadyPath.replace('.txt', '.auto-imported.txt');
            fs.renameSync(mcpReadyPath, importedPath);
            
        } catch (error) {
            console.error(`   ⚠️  Auto-import failed:`, error.message);
            console.log(`   📁 MCP-ready format available for manual import`);
        }
    }
    
    /**
     * Import session summary directly to basic-memory using uvx command
     */
    async importToBasicMemory(title, content) {
        const { spawn } = require('child_process');
        
        return new Promise((resolve, reject) => {
            const process = spawn('uvx', [
                'basic-memory', 'tool', 'write-note',
                '--title', title,
                '--folder', 'sessions', 
                '--content', content
            ], {
                cwd: '/home/neil/dev/new-claude-travel-agent'
            });
            
            let stdout = '';
            let stderr = '';
            
            process.stdout.on('data', (data) => {
                stdout += data.toString();
            });
            
            process.stderr.on('data', (data) => {
                stderr += data.toString();
            });
            
            process.on('close', (code) => {
                if (code === 0) {
                    resolve(stdout.trim());
                } else {
                    reject(new Error(stderr || `Process exited with code ${code}`));
                }
            });
        });
    }
    
    /**
     * Handle file system events
     */
    async handleFileEvent(eventType, filename) {
        // Only process .jsonl files
        if (!filename || !filename.endsWith('.jsonl')) {
            return;
        }
        
        // Avoid duplicate processing
        if (this.processingFiles.has(filename)) {
            return;
        }
        
        const filePath = path.join(this.traceDir, filename);
        
        // Check if file exists (might be a delete event)
        if (!fs.existsSync(filePath)) {
            return;
        }
        
        console.log(`📝 File event: ${eventType} - ${filename}`);
        
        // Mark as processing
        this.processingFiles.add(filename);
        
        try {
            // Wait for file stability
            console.log(`   ⏳ Waiting for file stability...`);
            await new Promise(resolve => setTimeout(resolve, this.fileStabilityDelay));
            
            // Double-check file is stable
            const isStable = await this.isFileStable(filePath);
            if (!isStable) {
                console.log(`   ⚠️  File still changing - waiting longer...`);
                await new Promise(resolve => setTimeout(resolve, this.fileStabilityDelay));
            }
            
            // Process the file
            await this.processSessionFile(filename);
            
        } finally {
            // Remove from processing set
            this.processingFiles.delete(filename);
        }
    }
    
    /**
     * Process existing files in the directory
     */
    async processExistingFiles() {
        try {
            const files = fs.readdirSync(this.traceDir)
                .filter(file => file.endsWith('.jsonl'))
                .sort(); // Process in chronological order
            
            if (files.length === 0) {
                console.log(`📂 No existing .jsonl files found in ${this.traceDir}`);
                return;
            }
            
            console.log(`📚 Processing ${files.length} existing session files...`);
            
            let processed = 0;
            for (const filename of files) {
                const success = await this.processSessionFile(filename);
                if (success) processed++;
            }
            
            console.log(`\n✅ Processed ${processed}/${files.length} existing sessions`);
            
        } catch (error) {
            console.error('Error processing existing files:', error.message);
        }
    }
    
    /**
     * Start watching for new files
     */
    startWatching() {
        if (!fs.existsSync(this.traceDir)) {
            console.error(`❌ Trace directory not found: ${this.traceDir}`);
            process.exit(1);
        }
        
        console.log(`\n👀 Starting file watcher on ${this.traceDir}`);
        
        const watcher = fs.watch(this.traceDir, { persistent: true }, (eventType, filename) => {
            this.handleFileEvent(eventType, filename).catch(error => {
                console.error(`Error handling file event:`, error.message);
            });
        });
        
        // Handle graceful shutdown
        process.on('SIGINT', () => {
            console.log('\n🛑 Shutting down session watcher...');
            watcher.close();
            process.exit(0);
        });
        
        console.log(`✅ File watcher active - press Ctrl+C to stop`);
        
        if (this.isDaemon) {
            console.log(`🚀 Running in daemon mode`);
        }
        
        return watcher;
    }
    
    /**
     * Run the full automation workflow
     */
    async run() {
        console.log(`🚀 Claude Code Session Automation Starting...\n`);
        
        // First process any existing files
        await this.processExistingFiles();
        
        // Then start watching for new ones
        this.startWatching();
        
        // Keep the process alive
        if (this.isDaemon) {
            process.stdin.resume();
        }
    }
}

// CLI interface
async function main() {
    const args = process.argv.slice(2);
    const isDaemon = args.includes('--daemon');
    const traceDir = args.find(arg => arg.startsWith('--trace-dir='))?.split('=')[1];
    const outputDir = args.find(arg => arg.startsWith('--output-dir='))?.split('=')[1];
    
    if (args.includes('--help')) {
        console.log(`
Claude Code Session Automation Watcher

Usage: node auto-session-watcher.js [options]

Options:
  --daemon              Run in daemon mode (keeps process alive)
  --trace-dir=PATH      Claude trace directory (default: ./.claude-trace)
  --output-dir=PATH     Output directory for summaries (default: /tmp/claude-sessions)
  --help                Show this help message

Examples:
  node auto-session-watcher.js                    # Process existing and watch for new
  node auto-session-watcher.js --daemon           # Run as background service
  node auto-session-watcher.js --trace-dir=/path  # Custom trace directory
        `);
        process.exit(0);
    }
    
    const watcher = new SessionWatcher({
        daemon: isDaemon,
        traceDir: traceDir,
        outputDir: outputDir
    });
    
    await watcher.run();
}

if (require.main === module) {
    main().catch(error => {
        console.error('Fatal error:', error);
        process.exit(1);
    });
}

module.exports = { SessionWatcher };